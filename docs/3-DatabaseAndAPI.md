# ZeroAge Database and API Specifications

## Table of Contents
1. [Database Schema](#database-schema)
2. [TypeScript Types](#typescript-types)
3. [API Specifications](#api-specifications)
4. [Data Flow Examples](#data-flow-examples)

## Database Schema

### Profiles Table
```sql
CREATE TABLE profiles (
  user_id UUID REFERENCES auth.users(id) PRIMARY KEY,
  name TEXT NOT NULL,
  weight NUMERIC CHECK (weight > 0),
  height NUMERIC CHECK (height > 0),
  body_fat NUMERIC(4,2) CHECK (body_fat >= 0), -- Added precision
  date_of_birth DATE, -- Can be null
  gender TEXT,
  unit TEXT CHECK (unit IN ('kg', 'lbs')) NOT NULL DEFAULT 'kg', -- Metric/Imperial Preference
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Sample Data
INSERT INTO profiles (user_id, name, weight, height, body_fat, unit) VALUES
('123e4567-e89b-12d3-a456-426614174000', 'John Doe', 75.5, 180, 15.00, 'kg');
```
*Comments*:
*   The `profiles` table stores user-specific information.
*   `user_id` is a foreign key referencing the `auth.users` table in Supabase's authentication schema.
*   `unit` column indicates the user's preference for metric or imperial units.

### Exercises Table
```sql
CREATE TABLE exercises (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL,
  primary_muscle TEXT NOT NULL, --  e.g., 'chest', 'legs', 'back'
  secondary_muscles TEXT[] NOT NULL DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Sample Data
INSERT INTO exercises (name, primary_muscle, secondary_muscles) VALUES
('Bench Press', 'chest', ARRAY['triceps', 'shoulders']),
('Squat', 'quadriceps', ARRAY['glutes', 'hamstrings']),
('Deadlift', 'back', ARRAY['glutes', 'hamstrings']);
```
*Comments*:
*   The `exercises` table stores a predefined list of exercises.
*   `primary_muscle` and `secondary_muscles` indicate the main muscle groups targeted by the exercise.
*   Consider using a migration tool (e.g., Flyway or Liquibase) to manage database schema changes.

### Workouts Table
```sql
CREATE TABLE workouts (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) NOT NULL,
  date DATE NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  -- Index for quick access to user's workouts and date filtering
  CONSTRAINT unique_user_workout UNIQUE (user_id, date) -- Removed created_at to allow multiple workouts per day
);

-- Sample Data
INSERT INTO workouts (user_id, date) VALUES
('123e4567-e89b-12d3-a456-426614174000', '2025-02-04');
```
*Comments*:
*   The `workouts` table stores information about user workouts.
*   The composite unique key constraint is modified to only include `user_id` and `date`, allowing a user to create multiple workouts on the same day.

### Workout Sets Table
```sql
CREATE TABLE workout_sets (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  workout_id BIGINT REFERENCES workouts(id) ON DELETE CASCADE,
  exercise_id BIGINT REFERENCES exercises(id),
  set_number SMALLINT NOT NULL, -- Changed to SMALLINT
  reps INTEGER NOT NULL CHECK (reps > 0),
  weight NUMERIC(5,2) NOT NULL CHECK (weight >= 0),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  -- Index for quick access to all sets in a workout
  CONSTRAINT unique_set_in_workout UNIQUE (workout_id, exercise_id, set_number)
);

-- Sample Data
INSERT INTO workout_sets (workout_id, exercise_id, set_number, reps, weight) VALUES
(1, 1, 1, 10, 60.00),
(1, 1, 2, 8, 65.00),
(1, 2, 1, 12, 100.00);
```
*Comments*:
*   The `workout_sets` table stores the sets performed within each workout.
*   `workout_id` references the `workouts` table and allows cascade deletion of workout sets if a workout is deleted.
*   `set_number` is changed to `SMALLINT` to optimize storage.

### Performance Optimizations

#### 1. Materialized Views

##### workout_history
```sql
CREATE MATERIALIZED VIEW workout_history AS
SELECT
    w.id,
    w.user_id,
    w.date,
    w.created_at,
    COUNT(DISTINCT ws.exercise_id) as exercise_count,
    COUNT(*) as total_sets,
    SUM(ws.reps * ws.weight) as total_volume
FROM workouts w
JOIN workout_sets ws ON w.id = ws.workout_id
GROUP BY w.id, w.user_id, w.date, w.created_at;
```

##### user_stats
```sql
CREATE MATERIALIZED VIEW user_stats AS
SELECT
    w.user_id,
    COUNT(DISTINCT w.id) as total_workouts,
    SUM(ws.reps * ws.weight) as total_volume,
    -- Assuming consecutive days with workouts determine a streak
    COUNT(DISTINCT w.date) FILTER (WHERE w.date >= CURRENT_DATE - INTERVAL '7 day') AS workouts_last_7_days, --Added count of workout for last 7 days
    MAX(CASE WHEN (w.date - LAG(w.date) OVER (PARTITION BY w.user_id ORDER BY w.date)) = 1 THEN 1 ELSE 0 END)
        OVER (PARTITION BY w.user_id ORDER BY w.date) as current_streak,
    (SELECT COUNT(*) from
     (SELECT date, (date - LAG(date, 1, date) OVER (ORDER BY date))::int as diff FROM workouts WHERE user_id = w.user_id ORDER BY date) t
      WHERE diff = 1
    ) as best_streak
FROM workouts w
JOIN workout_sets ws ON w.id = ws.workout_id
GROUP BY w.user_id;
```
*Comments*:
*   The `user_stats` materialized view provides precomputed user statistics.
*   The logic for calculating `current_streak` assumes consecutive days with workouts determine a streak, which might need further refinement based on specific requirements.
*   Added count of workouts for the last 7 days

##### volume_stats
```sql
CREATE MATERIALIZED VIEW volume_stats AS
WITH daily AS (
    SELECT user_id, date, SUM(reps * weight) as volume
    FROM workouts w
    JOIN workout_sets ws ON w.id = ws.workout_id
    GROUP BY user_id, date
),
weekly AS (
    SELECT user_id, DATE_TRUNC('week', date) AS week_start, SUM(volume) AS volume
    FROM daily
    GROUP BY user_id, DATE_TRUNC('week', date)
),
monthly AS (
    SELECT user_id, DATE_TRUNC('month', date) AS month_start, SUM(volume) AS volume
    FROM daily
    GROUP BY user_id, DATE_TRUNC('month', date)
)
SELECT
    d.user_id,
    d.date,
    d.volume as daily_volume,
    w.volume as weekly_volume,
    m.volume as monthly_volume
FROM daily d
JOIN weekly w ON d.user_id = w.user_id AND DATE_TRUNC('week', d.date) = w.week_start
JOIN monthly m ON d.user_id = m.user_id AND DATE_TRUNC('month', d.date) = m.month_start;
```
*Comments*:
*   The `volume_stats` materialized view stores pre-computed volume statistics at different time granularities.
*   Common Table Expressions (CTEs) are used to define `daily`, `weekly`, and `monthly` volume aggregations.

#### 2. Indexes

Strategic indexes for optimal query performance:

```sql
CREATE INDEX idx_workouts_user_date ON workouts(user_id, date);
CREATE INDEX idx_workout_sets_workout ON workout_sets(workout_id);
--CREATE INDEX idx_workouts_user_date_exists ON workouts(user_id, date)
--WHERE EXISTS (SELECT 1 FROM workout_sets WHERE workout_id = workouts.id); -- REMOVED
```
*Comments*:
*   `idx_workouts_user_date_exists` index has been removed.

#### 3. Auto-refresh Mechanism

Materialized views are automatically refreshed when data changes:

```sql
CREATE OR REPLACE FUNCTION refresh_stats()
RETURNS TRIGGER AS $$
BEGIN
  REFRESH MATERIALIZED VIEW CONCURRENTLY workout_history;
  REFRESH MATERIALIZED VIEW CONCURRENTLY user_stats;
  REFRESH MATERIALIZED VIEW CONCURRENTLY volume_stats;
  RETURN NULL;
END;
$$ LANGUAGE plpgsql;
```
*Comments*:
*   This function refreshes all materialized views concurrently, minimizing the impact on read performance.

## TypeScript Types

```typescript
import * as z from "zod";

// Profile Schema
export const profileSchema = z.object({
  userId: z.string().uuid(),
  name: z.string().min(1, { message: "Name must be at least 1 character." }),
  weight: z.number().positive().optional(),
  height: z.number().positive().optional(),
  bodyFat: z.number().nonnegative().lte(100).optional(),
  dateOfBirth: z.string().nullable().optional(), // Allow null for date of birth,
  gender: z.string().optional(),
  unit: z.enum(['kg', 'lbs']),
  createdAt: z.string().optional(),
  updatedAt: z.string().optional()
});

// Exercise Schema
export const exerciseSchema = z.object({
    id: z.number(),
    name: z.string().min(1),
    primaryMuscle: z.string().min(1),
    secondaryMuscles: z.array(z.string()),
    createdAt: z.string().optional(),
    updatedAt: z.string().optional(),
});

// WorkoutSet Schema
export const workoutSetSchema = z.object({
    setNumber: z.number().int().positive().lte(100),
    reps: z.number().int().positive(),
    weight: z.number().nonnegative()
});

// ExerciseWithSets Schema
export const exerciseWithSetsSchema = z.object({
    exercise: exerciseSchema,
    sets: z.array(workoutSetSchema)
});

// CreateWorkoutRequest Schema
export const createWorkoutRequestSchema = z.object({
  date: z.string(), // Format 'yyyy-MM-dd'
  exercises: z.array(
      exerciseWithSetsSchema
  )
});

// Workout Schema
export const workoutSchema = z.object({
    id: z.number(),
    date: z.string(),
    createdAt: z.string(),
    exercises: z.array(
        exerciseWithSetsSchema
    )
});

// Export Profile interface
export type Profile = z.infer<typeof profileSchema>;
export type Exercise = z.infer<typeof exerciseSchema>;
export type WorkoutSet = z.infer<typeof workoutSetSchema>;
export type ExerciseWithSets = z.infer<typeof exerciseWithSetsSchema>;
export type CreateWorkoutRequest = z.infer<typeof createWorkoutRequestSchema>;
export type Workout = z.infer<typeof workoutSchema>;
```
*Comments*:
*   Uses Zod for schema definition and validation.
*   Consistent naming conventions (camelCase)
*   `dateOfBirth` is now `string | null` to handle missing values.
*   The `exercise` in `ExerciseWithSets` is now the full `exerciseSchema` object and the field is renamed from `exerciseId`.

## API Specifications

### Profile APIs

#### Get Profile
```typescript
// GET /api/profile
// Response: Profile
{
  "userId": "123e4567-e89b-12d3-a456-426614174000",
  "name": "John Doe",
  "weight": 75.5,
  "height": 180,
  "bodyFat": 15,
  "dateOfBirth": "1990-01-01",
  "gender": "male",
  "unit": "kg",
  "createdAt": "2025-02-04T13:03:53Z",
  "updatedAt": "2025-02-04T13:03:53Z"
}
```

#### Update Profile
```typescript
// PUT /api/profile
// Request: Partial<Profile>
{
  "weight": 76.2,
  "height": 180,
  "bodyFat": 14.5,
  "unit": "kg"
}

// Response: Profile
// Same as GET /api/profile
```
*Comments*:
*   Uses `userId` to maintain naming consistency across the API.
*   Validates incoming request data using the `profileSchema`

### Exercise APIs

#### Get Exercises
```typescript
// GET /api/exercises
// Response: Exercise[]
[
  {
    "id": 1,
    "name": "Bench Press",
    "primaryMuscle": "chest",
    "secondaryMuscles": ["triceps", "shoulders"]
  }
]
```
*Comments*:
*   No parameters needed. This simply returns all exercises from the `exercises` table.

### Workout APIs

#### Create Workout
```typescript
// POST /api/workout
// Request: CreateWorkoutRequest
{
  "date": "2025-02-04",
  "exercises": [
    {
      "exercise": {
        "id": 1,
        "name": "Bench Press",
        "primaryMuscle": "chest",
        "secondaryMuscles": ["triceps", "shoulders"]
      },
      "sets": [
        { "setNumber": 1, "reps": 10, "weight": 60 },
        { "setNumber": 2, "reps": 8, "weight": 65 }
      ]
    }
  ]
}

// Response: Workout (Full workout object)
{
  "id": 1,
  "date": "2025-02-04",
  "createdAt": "2025-02-04T09:00:00Z",
  "exercises": [
    {
      "exercise": {
        "id": 1,
        "name": "Bench Press",
        "primaryMuscle": "chest",
        "secondaryMuscles": ["triceps", "shoulders"]
      },
      "sets": [
        { "setNumber": 1, "reps": 10, "weight": 60 },
        { "setNumber": 2, "reps": 8, "weight": 65 }
      ]
    }
  ]
}
```
*Comments*:
*   Returns the newly created Workout object to avoid another API call.

#### Get Workouts by Date
```typescript
// GET /api/workouts?date=2025-02-04&page=1&limit=10
// Response: Workout[]
[
  {
    "id": 1,
    "date": "2025-02-04",
    "createdAt": "2025-02-04T09:00:00Z",
    "exercises": [
      {
        "exercise": {
          "id": 1,
          "name": "Bench Press",
          "primaryMuscle": "chest",
          "secondaryMuscles": ["triceps", "shoulders"]
        },
        "sets": [
          { "setNumber": 1, "reps": 10, "weight": 60 },
          { "setNumber": 2, "reps": 8, "weight": 65 }
        ]
      }
    ]
  }
]
```
*Comments*:
*   Added pagination parameters `page` and `limit`.

#### Get Single Workout
```typescript
// GET /api/workout/:id
// Response: Workout
// Same structure as single workout in GET /api/workouts
```

#### Get Workout Dates
```typescript
// GET /api/workouts/dates
// Response: { dates: string[], totalWorkouts: number }
{
  "dates": ["2025-02-04", "2025-02-03", "2025-02-01"],
  "totalWorkouts": 10 // Fetched from user_stats MV
}
```
*Comments*:
*   `totalWorkouts` is retrieved from `user_stats` materialized view.

### Statistics and Analytics

#### Get User Statistics
```typescript
// GET /api/stats
// Response: { totalWorkouts: number, totalVolume: number, currentStreak: number, bestStreak: number }
{
  "totalWorkouts": 10,
  "totalVolume": 1000,
  "currentStreak": 5,
  "bestStreak": 10
}
```

#### Get Daily Volume Statistics
```typescript
// GET /api/stats/volume?startDate=2025-02-01&endDate=2025-02-28
// Response: Array of daily stats with weekly and monthly context
[
  {
    "date": "2025-02-01",
    "dailyVolume": 100,    // Total volume for this specific day
    "weeklyVolume": 500,   // Total volume for the week containing this day
    "monthlyVolume": 2000  // Total volume for the month containing this day
  }
]
```

#### Get Aggregated Volume Statistics
```typescript
// GET /api/stats/volume/aggregated?startDate=2025-01-01&endDate=2025-06-30&groupBy=week
// groupBy can be 'week' or 'month'
// Response for groupBy=week:
[
  {
    "period": "2025-W01",     // ISO week format: YYYY-Www
    "volume": 32000,          // Total volume for this week
    "startDate": "2025-01-01" // First day of the week
  },
  {
    "period": "2025-W02",
    "volume": 35000,
    "startDate": "2025-01-08"
  }
]

// Response for groupBy=month:
[
  {
    "period": "2025-01",      // YYYY-MM format
    "volume": 150000,         // Total volume for this month
    "startDate": "2025-01-01" // First day of the month
  },
  {
    "period": "2025-02",
    "volume": 140000,
    "startDate": "2025-02-01"
  }
]
```

## Data Flow Examples

### Creating a New Workout

1. **Frontend State (WorkoutLogger Component)**
```typescript
import { useState } from 'react';
import { ExerciseWithSets, workoutSetSchema } from './types'; // Updated import statement

const [exercises, setExercises] = useState<ExerciseWithSets[]>([]);

// When user adds sets
const handleAddSet = (exerciseId: number) => {
  setExercises(prev => prev.map(ex =>
    ex.exercise.id === exerciseId  // Correct comparison
      ? { ...ex, sets: [...ex.sets, workoutSetSchema.parse({ reps: 0, weight: 0 })] } // Parse the new set using Zod
      : ex
  ));
};
```

2. **API Call**
```typescript
import { createWorkoutRequestSchema } from './types'; // Import the validation schema
import { format } from 'date-fns';

const saveWorkout = async () => {
  // Create the workout data
  const workoutData = {
    date: format(new Date(), 'yyyy-MM-dd'),
    exercises: exercises
  };

  // Validate with Zod
  try {
    createWorkoutRequestSchema.parse(workoutData); // Will throw if invalid

    const response = await fetch('/api/workout', {
      method: 'POST',
      body: JSON.stringify(workoutData)
    });
    const newWorkout = await response.json();
    // Now you have a new workout
  } catch (error) {
    // Handle validation errors
    console.error("Validation failed:", error);
  }
};
```

3. **Database Operations**
```sql
-- 1. Create workout
INSERT INTO workouts (user_id, date)
VALUES ($1, $2)
RETURNING id;

-- 2. Create workout sets
INSERT INTO workout_sets (workout_id, exercise_id, set_number, reps, weight)
VALUES ($1, $2, $3, $4, $5);
```

### Viewing Workout History

1. **Database Query**
```sql
--Simplified query
SELECT
    w.id,
    w.date,
    w.created_at,
    e.id as exercise_id,
    e.name as exercise_name,
    e.primary_muscle,
    e.secondary_muscles,
    ws.set_number,
    ws.reps,
    ws.weight
FROM workouts w
JOIN workout_sets ws ON w.id = ws.workout_id
JOIN exercises e ON ws.exercise_id = e.id
WHERE w.user_id = $1 AND w.date = $2
ORDER BY w.created_at;
```

2. **API Response**
```typescript
// GET /api/workouts?date=2025-02-04
// Maps directly to Workout[] type
```

3. **Frontend Display (WorkoutHistory Component)**
```typescript
import { useState, useEffect } from 'react';
import { Workout } from './types'; //Import the workout object

const [workouts, setWorkouts] = useState<Workout[]>([]);

useEffect(() => {
    const fetchWorkouts = async () => {
        try {
            const response = await fetch(`/api/workouts?date=${selectedDate}`);
            if (!response.ok) {
                // Handle non-200 responses
                console.error(`Error fetching workouts: ${response.status} ${response.statusText}`);
                return;
            }

            const data = await response.json();

            // Assuming you have your workouts and sets in this nested form
            setWorkouts(data);
        } catch (error) {
            // Handle network errors and other exceptions
            console.error("Error fetching workouts:", error);
        }
    };

    fetchWorkouts();
}, [selectedDate]);
```

### Performance Characteristics

#### Write Operations
1. **Creating a Workout**: O(1)
   - Indexed inserts into workouts and workout_sets tables
   - Async materialized view refresh

2. **Updating Profile**: O(1)
   - Single row update with primary key

#### Read Operations
1. **Workout History**: O(1)
   - Pre-computed in workout_history materialized view

2. **Dashboard Stats**: O(1)
   - Pre-computed in user_stats materialized view

3. **Volume Analytics**: O(1)
   - Pre-computed in volume_stats materialized view

4.  Workout Calendar: O(log n)

#### Data Consistency
- Materialized views are refreshed automatically after each workout modification
- Concurrent refresh ensures reads are never blocked
- Strong consistency for direct table access
- Eventually consistent (typically < 1s) for materialized views
